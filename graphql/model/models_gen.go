// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package model

import (
	"fmt"
	"io"
	"net/url"
	"okp4/nemeton-leaderboard/app/nemeton"
	"strconv"
)

// Represents the progress/result of a task assigned to a validator.
type TaskState interface {
	IsTaskState()
	// The task we're talking about.
	GetTask() *nemeton.Task
	// `true` if the validator completed this task.
	GetCompleted() bool
	// The number of points earned by the validator on this task.
	GetEarnedPoints() uint64
}

// Represents the progress/result of a basic task assigned to a validator.
type BasicTaskState struct {
	// The task we're talking about.
	Task *nemeton.Task `json:"task"`
	// `true` if the validator completed this task.
	Completed bool `json:"completed"`
	// The number of points earned by the validator on this task.
	EarnedPoints uint64 `json:"earnedPoints"`
}

func (BasicTaskState) IsTaskState() {}

// The task we're talking about.
func (this BasicTaskState) GetTask() *nemeton.Task { return this.Task }

// `true` if the validator completed this task.
func (this BasicTaskState) GetCompleted() bool { return this.Completed }

// The number of points earned by the validator on this task.
func (this BasicTaskState) GetEarnedPoints() uint64 { return this.EarnedPoints }

// Represents a blockchain block range.
type BlockRange struct {
	// The block height the range begin, inclusive.
	From int `json:"from"`
	// The block height the range end, exclusive.
	To int `json:"to"`
	// The size of the range (i.e. `size` =  `to` - `from`).
	Count int `json:"count"`
}

// Represents a page of the Leaderboard.
type BoardConnection struct {
	// The page's validators, ordered by their rank.
	Edges []*ValidatorEdge `json:"edges"`
	// The information on the current connection page.
	PageInfo *PageInfo `json:"pageInfo"`
}

// Represents an identity on https://keybase.io/
type Identity struct {
	// The identity PGP key id.
	Kid string `json:"kid"`
	// The resolved identity picture, if any.
	Picture *Link `json:"picture"`
}

// A Link represents a relationship from the containing resource to a URI.
type Link struct {
	// The URI to the resource.
	//
	// Its value is either a URI compliant with [RFC3986](https://www.ietf.org/rfc/rfc3986.txt) or a URI Template compliant with
	// [RFC6570](https://tools.ietf.org/html/rfc6570).
	//
	// If the value is a URI Template then the Link Object shall have a `templated` attribute whose value is true.
	Href *url.URL `json:"href"`
}

// Contains information on a connection page.
type PageInfo struct {
	// The cursor of the first element of the page.
	StartCursor *nemeton.Cursor `json:"startCursor"`
	// The cursor of the last element of the page.
	EndCursor *nemeton.Cursor `json:"endCursor"`
	// `true` if there is other elements after the endCursor.
	HasNextPage bool `json:"hasNextPage"`
	// The number of elements in the page.
	Count int `json:"count"`
}

// Contains tasks state in the context of a phase and a validator.
type PerPhaseTasks struct {
	// The total number of tasks the validator completed in this phase.
	CompletedCount int `json:"completedCount"`
	// The total number of started tasks the validator is supposed to perform.
	StartedCount int `json:"startedCount"`
	// The total number of finished tasks in this phase.
	FinishedCount int `json:"finishedCount"`
	// The current points earned by the validator in this phase.
	Points uint64 `json:"points"`
	// The phase we're talking about.
	Phase *nemeton.Phase `json:"phase"`
	// The current status of the phase's tasks for a validator.
	Tasks []TaskState `json:"tasks"`
}

// Represents a Phases payload
type Phases struct {
	// Retrieve all the phases.
	All []*nemeton.Phase `json:"all"`
	// Retrieve all the ongoing phases, those who hasn't started yet.
	Ongoing []*nemeton.Phase `json:"ongoing"`
	// Retrieve all the finished phases.
	Finished []*nemeton.Phase `json:"finished"`
	// Retrieve the current phase.
	Current *nemeton.Phase `json:"current"`
}

// Represents the progress/result of a task assigned to a validator expecting a submission from him.
type SubmissionTaskState struct {
	// The task we're talking about.
	Task *nemeton.Task `json:"task"`
	// `true` if the validator completed this task.
	Completed bool `json:"completed"`
	// The number of points earned by the validator on this task.
	EarnedPoints uint64 `json:"earnedPoints"`
	// `true` if the validator submitted the expected content.
	Submitted bool `json:"submitted"`
}

func (SubmissionTaskState) IsTaskState() {}

// The task we're talking about.
func (this SubmissionTaskState) GetTask() *nemeton.Task { return this.Task }

// `true` if the validator completed this task.
func (this SubmissionTaskState) GetCompleted() bool { return this.Completed }

// The number of points earned by the validator on this task.
func (this SubmissionTaskState) GetEarnedPoints() uint64 { return this.EarnedPoints }

// Contains information relative to the state of the tasks a validator shall perform.
type Tasks struct {
	// The total number of tasks the validator completed.
	CompletedCount int `json:"completedCount"`
	// The total number of started tasks the validator is supposed to perform.
	StartedCount int `json:"startedCount"`
	// The total number of finished tasks the validator was supposed to perform.
	FinishedCount int `json:"finishedCount"`
	// Details the tasks state a validator is supposed to perform per phase.
	PerPhase []*PerPhaseTasks `json:"perPhase"`
	// Details the tasks state a validator is supposed to perform in the specified phase.
	ForPhase *PerPhaseTasks `json:"forPhase"`
}

// Represents an edge to a validator.
type ValidatorEdge struct {
	// The validator's cursor.
	Cursor *nemeton.Cursor `json:"cursor"`
	// The validator.
	Node *nemeton.Validator `json:"node"`
}

// Represents the status of a validator node on the blockchain.
type ValidatorStatus string

const (
	ValidatorStatusActive   ValidatorStatus = "ACTIVE"
	ValidatorStatusInactive ValidatorStatus = "INACTIVE"
	ValidatorStatusJailed   ValidatorStatus = "JAILED"
)

var AllValidatorStatus = []ValidatorStatus{
	ValidatorStatusActive,
	ValidatorStatusInactive,
	ValidatorStatusJailed,
}

func (e ValidatorStatus) IsValid() bool {
	switch e {
	case ValidatorStatusActive, ValidatorStatusInactive, ValidatorStatusJailed:
		return true
	}
	return false
}

func (e ValidatorStatus) String() string {
	return string(e)
}

func (e *ValidatorStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ValidatorStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ValidatorStatus", str)
	}
	return nil
}

func (e ValidatorStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}
