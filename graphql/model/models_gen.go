// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package model

import (
	"fmt"
	"io"
	"strconv"
	"time"
)

// Represents the progress/result of a task assigned to a validator.
type TaskState interface {
	IsTaskState()
	// The task we're talking about.
	GetTask() *Task
	// `true` if the validator  completed this task.
	GetCompleted() bool
	// The number of points earned by the validator on this task.
	GetEarnedPoints() int
}

// Represents a blockchain block range.
type BlockRange struct {
	// The block height the range begin, inclusive.
	From int `json:"from"`
	// The block height the range end, inclusive.
	To int `json:"to"`
	// The size of the range (i.e. `size` =  `to` - `from`).
	Count int `json:"count"`
}

// Represents a page of the Leaderboard.
type BoardConnection struct {
	// The page's validators, ordered by their rank.
	Edges []*ValidatorEdge `json:"edges"`
	// The information on the current connection page.
	PageInfo *PageInfo `json:"pageInfo"`
}

// Represents an identity on https://keybase.io/
type Identity struct {
	// The identity PGP key id.
	PGP string `json:"pgp"`
	// The resolved identity picture, if any.
	Picture *Link `json:"picture"`
}

// A Link represents a relationship from the containing resource to a URI.
type Link struct {
	// The URI to the resource.
	//
	// Its value is either a URI compliant with [RFC3986](https://www.ietf.org/rfc/rfc3986.txt) or a URI Template compliant with
	// [RFC6570](https://tools.ietf.org/html/rfc6570).
	//
	// If the value is a URI Template then the Link Object shall have a `templated` attribute whose value is true.
	Href string `json:"href"`
}

// Contains information on a connection page.
type PageInfo struct {
	// The cursor of the first element of the page.
	StartCursor string `json:"startCursor"`
	// The cursor of the last element of the page.
	EndCursor string `json:"endCursor"`
	// `true` if there is other elements after the endCursor.
	HasNextPage bool `json:"hasNextPage"`
	// The number of elements in the page.
	Count int `json:"count"`
}

// Contains tasks state in the context of a phase and a validator.
type PerPhaseTasks struct {
	// The total number of tasks the validator completed in this phase.
	CompletedCount int `json:"completedCount"`
	// The total number of finished tasks in this phase.
	FinishedCount int `json:"finishedCount"`
	// The phase we're talking about.
	Phase *Phase `json:"phase"`
	// The current status of the phase's tasks for a validator.
	Tasks []TaskState `json:"tasks"`
}

// Represents a Phase of the Nemeton Program
type Phase struct {
	// Identify the phase, the phases are ordered through their number.
	Number int `json:"number"`
	// The name of the phase.
	Name string `json:"name"`
	// The description of the phase.
	Description string `json:"description"`
	// The date the phase begin.
	StartDate time.Time `json:"startDate"`
	// The date the phase end.
	EndDate time.Time `json:"endDate"`
	// `true` if the phase is in progress.
	Started bool `json:"started"`
	// `true` if the phase is finished.
	Finished bool `json:"finished"`
	// The tasks composing the phase the druids will have to perform.
	Tasks []*Task `json:"tasks"`
	// The current block range of the phase. In the case the phase hasn't started its size is 0, for a phase in progress the range will evolve.
	Blocks *BlockRange `json:"blocks"`
}

// Represents a Phases payload
type Phases struct {
	// Retrieve all the phases.
	All []*Phase `json:"all"`
	// Retrieve all the ongoing phases, those who hasn't started yet.
	Ongoing []*Phase `json:"ongoing"`
	// Retrieve all the finished phases.
	Finished []*Phase `json:"finished"`
	// Retrieve the current phase.
	Current *Phase `json:"current"`
}

// Represents the state of a specific task requiring a manual submission from the validator.
type SubmissionTask struct {
	// The task we're talking about.
	Task *Task `json:"task"`
	// `true` if the validator  completed this task.
	Completed bool `json:"completed"`
	// The number of points earned by the validator on this task.
	EarnedPoints int `json:"earnedPoints"`
	// `true` if the validator has submitted the content expected for the task.
	Submitted bool `json:"submitted"`
}

func (SubmissionTask) IsTaskState() {}

// The task we're talking about.
func (this SubmissionTask) GetTask() *Task { return this.Task }

// `true` if the validator  completed this task.
func (this SubmissionTask) GetCompleted() bool { return this.Completed }

// The number of points earned by the validator on this task.
func (this SubmissionTask) GetEarnedPoints() int { return this.EarnedPoints }

// Represents a phase's task, containing only descriptive elements. It does not expressed any potential progress or result as it is not linked to a druid.
type Task struct {
	// The unique identifier of the task.
	ID string `json:"id"`
	// The name of the task.
	Name string `json:"name"`
	// The description of the task.
	Description string `json:"description"`
	// The date the task being.
	StartDate time.Time `json:"startDate"`
	// The date the task end.
	EndDate time.Time `json:"endDate"`
	// `true` if the task is in progress.
	Started bool `json:"started"`
	// `true` if the task is finished.
	Finished bool `json:"finished"`
	// Tells whether a task require a manual submission from the druids to be evaluated.
	WithSubmission bool `json:"withSubmission"`
	// The points earned if the task is completed. No value means there is no fixed amount of points as rewards, the amount is calculated regarding the performance.
	Rewards *int `json:"rewards"`
}

// Contains information relative to the state of the tasks a validator shall perform.
type Tasks struct {
	// The total number of tasks the validator completed.
	CompletedCount int `json:"completedCount"`
	// The total number of finished tasks the validator was supposed to perform.
	FinishedCount int `json:"finishedCount"`
	// Details the tasks state a validator is supposed to perform per phase.
	PerPhase []*PerPhaseTasks `json:"perPhase"`
}

// Represents the state of a specific task of uptime.
type UptimeTask struct {
	// The task we're talking about.
	Task *Task `json:"task"`
	// `true` if the validator  completed this task.
	Completed bool `json:"completed"`
	// The number of points earned by the validator on this task.
	EarnedPoints int `json:"earnedPoints"`
	// The total number of blocks expected to be signed.
	BlockCount int `json:"blockCount"`
	// The number of missed blocks.
	MissedBlockCount int `json:"missedBlockCount"`
	// The missed block ranges.
	MissedBlocks []*BlockRange `json:"missedBlocks"`
	// The ratio of signed blocks.
	Ratio int `json:"ratio"`
}

func (UptimeTask) IsTaskState() {}

// The task we're talking about.
func (this UptimeTask) GetTask() *Task { return this.Task }

// `true` if the validator  completed this task.
func (this UptimeTask) GetCompleted() bool { return this.Completed }

// The number of points earned by the validator on this task.
func (this UptimeTask) GetEarnedPoints() int { return this.EarnedPoints }

// Represents a validator, a participant or a druid in the Nemeton program.
type Validator struct {
	// The validator position in the board.
	Rank int `json:"rank"`
	// The validator moniker.
	Moniker string `json:"moniker"`
	// The validator identity on https://keybase.io/, can be used to retrieve its picture.
	Identity *Identity `json:"identity"`
	// The validator node valoper address.
	Valoper string `json:"valoper"`
	// The address of the validator node delegator.
	Delegator string `json:"delegator"`
	// The validator twitter account.
	Twitter *string `json:"twitter"`
	// The validator discord account.
	Discord string `json:"discord"`
	// The validator country.
	Country string `json:"country"`
	// The validator current status.
	Status ValidatorStatus `json:"status"`
	// The validator points count.
	Points int `json:"points"`
	// The validator affected tasks, does not reference not tasks who has not started yet.
	Tasks *Tasks `json:"tasks"`
	// The blocks the validator has not signed.
	MissedBlocks []*BlockRange `json:"missedBlocks"`
}

// Represents an edge to a validator.
type ValidatorEdge struct {
	// The validator's cursor.
	Cursor string `json:"cursor"`
	// The validator.
	Node *Validator `json:"node"`
}

// Represents the status of a validator node on the blockchain.
type ValidatorStatus string

const (
	ValidatorStatusActive   ValidatorStatus = "ACTIVE"
	ValidatorStatusInactive ValidatorStatus = "INACTIVE"
	ValidatorStatusJailed   ValidatorStatus = "JAILED"
)

var AllValidatorStatus = []ValidatorStatus{
	ValidatorStatusActive,
	ValidatorStatusInactive,
	ValidatorStatusJailed,
}

func (e ValidatorStatus) IsValid() bool {
	switch e {
	case ValidatorStatusActive, ValidatorStatusInactive, ValidatorStatusJailed:
		return true
	}
	return false
}

func (e ValidatorStatus) String() string {
	return string(e)
}

func (e *ValidatorStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ValidatorStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ValidatorStatus", str)
	}
	return nil
}

func (e ValidatorStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}
