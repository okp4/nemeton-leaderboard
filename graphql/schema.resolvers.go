package graphql

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.24

import (
	"context"
	"fmt"
	"net/url"
	"okp4/nemeton-leaderboard/app/event"
	"okp4/nemeton-leaderboard/app/message"
	"okp4/nemeton-leaderboard/app/nemeton"
	"okp4/nemeton-leaderboard/graphql/generated"
	"okp4/nemeton-leaderboard/graphql/model"

	cryptotypes "github.com/cosmos/cosmos-sdk/crypto/types"
	"github.com/cosmos/cosmos-sdk/simapp"
	"github.com/cosmos/cosmos-sdk/types"
	"github.com/rs/zerolog/log"
)

// Picture is the resolver for the picture field.
func (r *identityResolver) Picture(ctx context.Context, obj *model.Identity) (*model.Link, error) {
	picture, err := r.keybaseClient.LookupPicture(ctx, obj.Kid)
	if err != nil {
		return nil, err
	}

	var link *model.Link
	if picture != nil {
		link = &model.Link{Href: picture}
	}
	return link, nil
}

// SubmitValidatorGenTx is the resolver for the submitValidatorGenTX field.
func (r *mutationResolver) SubmitValidatorGenTx(ctx context.Context, twitter *string, discord string, country string, gentx map[string]interface{}) (*string, error) {
	evt := GenTXSubmittedEvent{
		Twitter: twitter,
		Discord: discord,
		Country: country,
		GenTX:   gentx,
	}
	rawEvt, err := evt.Marshal()
	if err != nil {
		return nil, err
	}

	r.actorCTX.Send(
		r.eventStore,
		&message.PublishEventMessage{
			Event: event.NewEvent(
				GenTXSubmittedEventType,
				rawEvt,
			),
		},
	)
	return nil, nil
}

// RegisterValidator is the resolver for the registerValidator field.
func (r *mutationResolver) RegisterValidator(ctx context.Context, twitter *string, discord string, country string, delegator types.AccAddress, validator types.ValAddress) (*string, error) {
	val, err := r.FetchValidator(validator)
	if err != nil {
		log.Err(err).Str("valoper", validator.String()).Msg("ðŸ¤• Couldn't fetch validator")
		return nil, err
	}

	var pubkey cryptotypes.PubKey
	if err := simapp.MakeTestEncodingConfig().InterfaceRegistry.UnpackAny(val.ConsensusPubkey, &pubkey); err != nil {
		log.Err(err).Str("valoper", validator.String()).Msg("ðŸ¤• Couldn't get pubkey of validator")
		return nil, err
	}

	evt := ValidatorRegisteredEvent{
		Twitter:     twitter,
		Discord:     discord,
		Country:     country,
		Valoper:     validator,
		Delegator:   delegator,
		Valcons:     types.GetConsAddress(pubkey),
		Description: val.Description,
	}
	rawEvt, err := evt.Marshal()
	if err != nil {
		return nil, err
	}

	r.actorCTX.Send(
		r.eventStore,
		&message.PublishEventMessage{
			Event: event.NewEvent(
				ValidatorRegisteredEventType,
				rawEvt,
			),
		},
	)
	return nil, nil
}

// UpdateValidator is the resolver for the updateValidator field.
func (r *mutationResolver) UpdateValidator(ctx context.Context, delegator types.AccAddress, twitter *string, discord string, country string, valoper types.ValAddress) (*string, error) {
	val, err := r.FetchValidator(valoper)
	if err != nil {
		log.Err(err).Str("valoper", valoper.String()).Msg("ðŸ¤• Couldn't fetch validator")
		return nil, err
	}

	var pubkey cryptotypes.PubKey
	if err := simapp.MakeTestEncodingConfig().InterfaceRegistry.UnpackAny(val.ConsensusPubkey, &pubkey); err != nil {
		log.Err(err).Str("valoper", valoper.String()).Msg("ðŸ¤• Couldn't get pubkey of validator")
		return nil, err
	}

	evt := ValidatorRegisteredEvent{
		Twitter:     twitter,
		Discord:     discord,
		Country:     country,
		Valoper:     valoper,
		Delegator:   delegator,
		Valcons:     types.GetConsAddress(pubkey),
		Description: val.Description,
	}
	rawEvt, err := evt.Marshal()
	if err != nil {
		return nil, err
	}

	r.actorCTX.Send(
		r.eventStore,
		&message.PublishEventMessage{
			Event: event.NewEvent(
				ValidatorUpdatedEventType,
				rawEvt,
			),
		},
	)
	return nil, nil
}

// RemoveValidator is the resolver for the removeValidator field.
func (r *mutationResolver) RemoveValidator(ctx context.Context, validator types.ValAddress) (*string, error) {
	_, err := r.FetchValidator(validator)
	if err != nil {
		log.Err(err).Str("valoper", validator.String()).Msg("ðŸ¤• Couldn't fetch validator")
		return nil, err
	}

	evt := ValidatorRemovedEvent{
		Validator: validator,
	}
	rawEvt, err := evt.Marshal()
	if err != nil {
		return nil, err
	}

	r.actorCTX.Send(
		r.eventStore,
		&message.PublishEventMessage{
			Event: event.NewEvent(
				ValidatorRemovedEventType,
				rawEvt,
			),
		},
	)
	return nil, nil
}

// SubmitTask is the resolver for the submitTask field.
func (r *mutationResolver) SubmitTask(ctx context.Context, validator types.ValAddress, phase int, task string) (*string, error) {
	evt := TaskSubmittedEvent{
		Validator: validator,
		Phase:     phase,
		Task:      task,
	}
	rawEvt, err := evt.Marshal()
	if err != nil {
		return nil, err
	}

	r.actorCTX.Send(
		r.eventStore,
		&message.PublishEventMessage{
			Event: event.NewEvent(
				TaskSubmittedEventType,
				rawEvt,
			),
		},
	)
	return nil, nil
}

// RegisterRPCEndpoint is the resolver for the registerRPCEndpoint field.
func (r *mutationResolver) RegisterRPCEndpoint(ctx context.Context, validator types.ValAddress, url *url.URL) (*string, error) {
	evt := RegisterURLEvent{
		Type:      nemeton.TaskTypeRPC,
		Validator: validator,
		URL:       url,
		Points:    nil,
	}
	rawEvt, err := evt.Marshal()
	if err != nil {
		return nil, err
	}

	r.actorCTX.Send(
		r.eventStore,
		&message.PublishEventMessage{
			Event: event.NewEvent(
				RegisterURLEventType,
				rawEvt,
			),
		},
	)
	return nil, nil
}

// RegisterSnapshotURL is the resolver for the registerSnapshotURL field.
func (r *mutationResolver) RegisterSnapshotURL(ctx context.Context, validator types.ValAddress, url *url.URL) (*string, error) {
	evt := RegisterURLEvent{
		Type:      nemeton.TaskTypeSnapshots,
		Validator: validator,
		URL:       url,
		Points:    nil,
	}
	rawEvt, err := evt.Marshal()
	if err != nil {
		return nil, err
	}

	r.actorCTX.Send(
		r.eventStore,
		&message.PublishEventMessage{
			Event: event.NewEvent(
				RegisterURLEventType,
				rawEvt,
			),
		},
	)
	return nil, nil
}

// RegisterDashboardURL is the resolver for the registerDashboardURL field.
func (r *mutationResolver) RegisterDashboardURL(ctx context.Context, validator types.ValAddress, url *url.URL, points uint64) (*string, error) {
	phase := r.store.GetCurrentPhase()
	for _, task := range phase.Tasks {
		if task.Type == nemeton.TaskTypeDashboard {
			if maxPoints := task.GetParamMaxPoints(); maxPoints != nil && points > *maxPoints {
				return nil, fmt.Errorf("the maximum number of points allowed for this task is %d, you give %d points", *maxPoints, points)
			}
		}
	}

	evt := RegisterURLEvent{
		Type:      nemeton.TaskTypeDashboard,
		Validator: validator,
		URL:       url,
		Points:    &points,
	}
	rawEvt, err := evt.Marshal()
	if err != nil {
		return nil, err
	}

	r.actorCTX.Send(
		r.eventStore,
		&message.PublishEventMessage{
			Event: event.NewEvent(
				RegisterURLEventType,
				rawEvt,
			),
		},
	)
	return nil, nil
}

// CompleteTask is the resolver for the completeTask field.
func (r *mutationResolver) CompleteTask(ctx context.Context, validator types.ValAddress, phase int, task string, points *uint64) (*string, error) {
	evt := &TaskCompletedEvent{
		Validator: validator,
		Phase:     phase,
		Task:      task,
		Points:    points,
	}
	rawEvt, err := evt.Marshal()
	if err != nil {
		return nil, err
	}

	r.actorCTX.Send(
		r.eventStore,
		&message.PublishEventMessage{
			Event: event.NewEvent(
				TaskCompletedEventType,
				rawEvt,
			),
		},
	)
	return nil, nil
}

// SubmitBonusPoints is the resolver for the submitBonusPoints field.
func (r *mutationResolver) SubmitBonusPoints(ctx context.Context, validator types.ValAddress, points uint64, reason string) (*string, error) {
	evt := &BonusPointsSubmittedEvent{
		Validator: validator,
		Points:    points,
		Reason:    reason,
	}
	rawEvt, err := evt.Marshal()
	if err != nil {
		return nil, err
	}

	r.actorCTX.Send(
		r.eventStore,
		&message.PublishEventMessage{
			Event: event.NewEvent(
				BonusPointsSubmittedEventType,
				rawEvt,
			),
		},
	)
	return nil, nil
}

// Blocks is the resolver for the blocks field.
func (r *phaseResolver) Blocks(ctx context.Context, obj *nemeton.Phase) (*model.BlockRange, error) {
	blocks, err := r.store.GetPhaseBlocks(ctx, obj.Number)
	if err != nil {
	}

	if err != nil {
		return nil, err
	}

	if blocks != nil {
		from := int(blocks.From)
		to := int(blocks.To)
		return &model.BlockRange{
			From:  from,
			To:    to,
			Count: to - from,
		}, nil
	}
	return nil, nil
}

// All is the resolver for the all field.
func (r *phasesResolver) All(ctx context.Context, obj *model.Phases) ([]*nemeton.Phase, error) {
	return r.store.GetAllPhases(), nil
}

// Ongoing is the resolver for the ongoing field.
func (r *phasesResolver) Ongoing(ctx context.Context, obj *model.Phases) ([]*nemeton.Phase, error) {
	return r.store.GetUnstartedPhases(), nil
}

// Finished is the resolver for the finished field.
func (r *phasesResolver) Finished(ctx context.Context, obj *model.Phases) ([]*nemeton.Phase, error) {
	return r.store.GetFinishedPhases(), nil
}

// Current is the resolver for the current field.
func (r *phasesResolver) Current(ctx context.Context, obj *model.Phases) (*nemeton.Phase, error) {
	return r.store.GetCurrentPhase(), nil
}

// Phase is the resolver for the phase field.
func (r *queryResolver) Phase(ctx context.Context, number int) (*nemeton.Phase, error) {
	return r.store.GetPhase(number), nil
}

// Phases is the resolver for the phases field.
func (r *queryResolver) Phases(ctx context.Context) (*model.Phases, error) {
	return &model.Phases{}, nil
}

// Board is the resolver for the board field.
func (r *queryResolver) Board(ctx context.Context, search *string, first *int, after *nemeton.Cursor) (*model.BoardConnection, error) {
	validators, hasNext, err := r.store.GetBoard(ctx, search, *first, after)
	if err != nil {
		return nil, err
	}

	edges := make([]*model.ValidatorEdge, 0, len(validators))
	for _, validator := range validators {
		edges = append(edges, &model.ValidatorEdge{
			Cursor: validator.Cursor(),
			Node:   validator,
		})
	}

	var startCursor *nemeton.Cursor
	var endCursor *nemeton.Cursor
	if len(edges) > 0 {
		startCursor = edges[0].Cursor
		endCursor = edges[len(validators)-1].Cursor
	}

	return &model.BoardConnection{
		Edges: edges,
		PageInfo: &model.PageInfo{
			StartCursor: startCursor,
			EndCursor:   endCursor,
			HasNextPage: hasNext,
			Count:       len(validators),
		},
	}, nil
}

// ValidatorCount is the resolver for the validatorCount field.
func (r *queryResolver) ValidatorCount(ctx context.Context) (int, error) {
	count, err := r.store.CountValidators(ctx)
	return int(count), err
}

// Validator is the resolver for the validator field.
func (r *queryResolver) Validator(ctx context.Context, cursor *nemeton.Cursor, rank *int, valoper types.ValAddress, delegator types.AccAddress, discord *string, twitter *string) (*nemeton.Validator, error) {
	if cursor != nil {
		return r.store.GetValidatorByCursor(ctx, *cursor)
	}
	if rank != nil {
		panic(fmt.Errorf("not implemented: Validator - validator"))
	}
	if !valoper.Empty() {
		return r.store.GetValidatorByValoper(ctx, valoper)
	}
	if !delegator.Empty() {
		return r.store.GetValidatorByDelegator(ctx, delegator)
	}
	if discord != nil {
		return r.store.GetValidatorByDiscord(ctx, *discord)
	}
	if twitter != nil {
		return r.store.GetValidatorByTwitter(ctx, *twitter)
	}
	return nil, fmt.Errorf("one option must be passed")
}

// ForPhase is the resolver for the forPhase field.
func (r *tasksResolver) ForPhase(ctx context.Context, obj *model.Tasks, number int) (*model.PerPhaseTasks, error) {
	panic(fmt.Errorf("not implemented: ForPhase - forPhase"))
}

// Rank is the resolver for the rank field.
func (r *validatorResolver) Rank(ctx context.Context, obj *nemeton.Validator) (int, error) {
	return r.store.GetValidatorRank(ctx, *obj.Cursor())
}

// Identity is the resolver for the identity field.
func (r *validatorResolver) Identity(ctx context.Context, obj *nemeton.Validator) (*model.Identity, error) {
	if obj.Identity == nil {
		return nil, nil
	}

	return &model.Identity{
		Kid: *obj.Identity,
	}, nil
}

// Status is the resolver for the status field.
func (r *validatorResolver) Status(ctx context.Context, obj *nemeton.Validator) (model.ValidatorStatus, error) {
	panic(fmt.Errorf("not implemented: Status - status"))
}

// Tasks is the resolver for the tasks field.
func (r *validatorResolver) Tasks(ctx context.Context, obj *nemeton.Validator) (*model.Tasks, error) {
	result := &model.Tasks{
		CompletedCount: 0,
		StartedCount:   0,
		FinishedCount:  0,
	}
	for _, phase := range r.store.GetAllPhases() {
		perPhase := &model.PerPhaseTasks{
			CompletedCount: 0,
			StartedCount:   0,
			FinishedCount:  0,
			Points:         0,
			Phase:          phase,
		}
		for i, task := range phase.Tasks {
			completed := false
			earnedPoints := uint64(0)
			submitted := false
			if state := obj.Task(phase.Number, task.ID); state != nil {
				completed = state.Completed
				earnedPoints = state.EarnedPoints
				submitted = state.Submitted
			}

			var mappedState model.TaskState
			if task.WithSubmission() {
				mappedState = model.SubmissionTaskState{
					Task:         &phase.Tasks[i],
					Completed:    completed,
					EarnedPoints: earnedPoints,
					Submitted:    submitted,
				}
			} else {
				mappedState = model.BasicTaskState{
					Task:         &phase.Tasks[i],
					Completed:    completed,
					EarnedPoints: earnedPoints,
				}
			}

			if mappedState.GetCompleted() {
				perPhase.CompletedCount++
			}
			if task.Started() {
				perPhase.StartedCount++
			}
			if task.Finished() {
				perPhase.FinishedCount++
			}
			perPhase.Tasks = append(perPhase.Tasks, mappedState)
			perPhase.Points += mappedState.GetEarnedPoints()
		}

		result.CompletedCount += perPhase.CompletedCount
		result.StartedCount += perPhase.StartedCount
		result.FinishedCount += perPhase.FinishedCount
		result.PerPhase = append(result.PerPhase, perPhase)
	}

	return result, nil
}

// MissedBlocks is the resolver for the missedBlocks field.
func (r *validatorResolver) MissedBlocks(ctx context.Context, obj *nemeton.Validator) ([]*model.BlockRange, error) {
	panic(fmt.Errorf("not implemented: MissedBlocks - missedBlocks"))
}

// Identity returns generated.IdentityResolver implementation.
func (r *Resolver) Identity() generated.IdentityResolver { return &identityResolver{r} }

// Mutation returns generated.MutationResolver implementation.
func (r *Resolver) Mutation() generated.MutationResolver { return &mutationResolver{r} }

// Phase returns generated.PhaseResolver implementation.
func (r *Resolver) Phase() generated.PhaseResolver { return &phaseResolver{r} }

// Phases returns generated.PhasesResolver implementation.
func (r *Resolver) Phases() generated.PhasesResolver { return &phasesResolver{r} }

// Query returns generated.QueryResolver implementation.
func (r *Resolver) Query() generated.QueryResolver { return &queryResolver{r} }

// Tasks returns generated.TasksResolver implementation.
func (r *Resolver) Tasks() generated.TasksResolver { return &tasksResolver{r} }

// Validator returns generated.ValidatorResolver implementation.
func (r *Resolver) Validator() generated.ValidatorResolver { return &validatorResolver{r} }

type identityResolver struct{ *Resolver }
type mutationResolver struct{ *Resolver }
type phaseResolver struct{ *Resolver }
type phasesResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
type tasksResolver struct{ *Resolver }
type validatorResolver struct{ *Resolver }
